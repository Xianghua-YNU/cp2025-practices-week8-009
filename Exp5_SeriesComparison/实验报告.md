# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - （描述实现方法）
def sum_S1(N):
    s = 0.0
    for n in range(1, 2 * N + 1):
        term = (-1) ** n * n / (n + 1)
        s += term
    return s
2. `sum_S2(N)` 函数实现：
   - （描述实现方法）
def sum_S2(N):
    sum1 = 0.0
    sum2 = 0.0
    for n in range(1, N + 1):
        sum1 += (2 * n - 1) / (2 * n)
        sum2 += (2 * n) / (2 * n + 1)
    return sum2 - sum1
3. `sum_S3(N)` 函数实现：
   - （描述实现方法）
def sum_S3(N):
    s = 0.0
    for n in range(1, N + 1):
        term = 1 / (2 * n * (2 * n + 1))
        s += term
    return s
### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |  2.836095e-01           |  2.836095e-01           |   2.836095e-01            |     3.91e-16            |   4.70e-15             |
| 100 |3.043714e-01           |   3.043714e-01           |   3.043714e-01           |   2.55e-15               |    1.51e-13              |
| 1000 |    3.066030e-01        | 3.066030e-01            |     3.066030e-01          |  1.16e-14               |   5.75e-12               |
| 10000 |  3.068278e-01         |    3.068278e-01           |     3.068278e-01          |   5.26e-14             |    5.62e-11               |

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）
![image](https://github.com/user-attachments/assets/67869b36-c4d6-4457-8314-7c26d1f473e6)

## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更小）：S3（直接求和）的误差最小，因为它是单纯的正项级数求和，每一步的增量逐渐减小，舍入误差不会因正负相消而放大。S2（分项求和相减）误差次之，尽管涉及两个正项求和，但相减时可能发生灾难性抵消（两个相近的大数相减导致有效数字丢失）。S1（交错级数）误差最大，因为交替的正负项在累加时不断相互抵消，导致有效位数逐渐丢失，舍入误差累积显著。
   - （分析误差增长速度）：S1的误差增长：近似与 N成线性关系（幂指数约1）。由于每次加减项的量级相近，舍入误差随项数线性累积。S2的误差增长：通常与 N 的更高次幂相关（幂指数可能接近1.5-2），因为两个独立求和的误差在相减时被放大，且项数随 N增加。

2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）：两和相减时，主项 N 被抵消，剩余量级为 O(ln⁡N)，而原始求和结果的量级为 O(N)。因此，两个大数相减后的小结果会放大舍入误差，导致有效数字大量丢失。
   - （解释为什么会发生灾难性抵消）：当两个相近的大数相减时，高位有效数字相互抵消，剩余的低位数字可能被舍入误差主导。

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）S1的误差曲线：近似斜率为1（线性增长），表明误差 ∝N1。S2的误差曲线：斜率可能接近1.5e-2（超线性增长），表明误差 ∝N1.5或N2
   - （估算幂指数p）通过双对数图中的斜率来得到

2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）舍入误差累积：浮点数运算每次会引入约 10 e−16的相对误差。对于 O(N) 次运算，误差累积量级为 O(N⋅10 −16)。运算形式的影S1的交错加减导致误差随机累积，但总体线性增长。S2的灾难性抵消使误差随N 的幂次增长更快。

## 6. 结论
1. 不同计算形式的数值稳定性比较：S3最优S2次优S1最差	
2. 灾难性抵消对计算精度的影响：当数学表达式中包含相近大数相减时，有效数字丢失是误差的主要来源。
3. 数学等价与数值计算的关系：数学上等价的表达式在数值计算中可能因运算顺序、抵消现象等导致完全不同的误差特性。数值稳定性是选择计算形式时的关键考量。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
浮点数精度限制：计算机使用有限位数（如64位双精度）表示实数，每一步运算引入舍入误差。
运算顺序与抵消：不同的表达式可能导致舍入误差以不同方式累积（如S1的交替符号、S2的大数相减）。
2. 在实际编程中，如何避免类似的数值不稳定性？
避免大数相减：通过代数变形将相减操作转换为其他形式（如S3）。
使用补偿求和算法：如Kahan求和法，减少累加误差。
选择稳定表达式：优先使用单调收敛的级数形式（如S3的正项求和）。
3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
解析化简：对原始级数进行数学分析，找到闭合表达式。
## 附录：关键代码
```python
# def calculate_relative_errors(N_values):
    err1 = []
    err2 = []
    for N in N_values:
        s1 = sum_S1(N)
        s2 = sum_S2(N)
        s3 = sum_S3(N)
        if s3 == 0:
            e1 = e2 = 0.0
        else:
            e1 = abs(s1 - s3) / abs(s3)
            e2 = abs(s2 - s3) / abs(s3)
        err1.append(e1)
        err2.append(e2)
    return (err1, err2)

def plot_errors(N_values, err1, err2):
    plt.loglog(N_values, err1, label='Relative Error of S1')
    plt.loglog(N_values, err2, label='Relative Error of S2')
    plt.xlabel('N (log scale)')
    plt.ylabel('Relative Error (log scale)')
    plt.title('Relative Error Comparison')
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.show()
```
